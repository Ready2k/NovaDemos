/**
 * Voice Switch Transition Handler
 * 
 * Manages voice switching workflow with user notifications
 * and transition messages generated by Gemini 3 Pro.
 */

import { BedrockRuntimeClient, InvokeModelCommand } from '@aws-sdk/client-bedrock-runtime';

export interface VoiceSwitchTransition {
    shouldSwitch: boolean;
    fromVoice: string;
    toVoice: string;
    detectedLocale: string;
    confidence: number;
    transitionMessage: string;
}

export interface ClientSession {
    voiceId?: string;
    voiceLockEnabled?: boolean;
    voiceMapping?: Record<string, string>;
    activeLocale?: string;
    localeConfidence?: number;
}

/**
 * Generate a natural transition message using Gemini 3 Pro
 * 
 * @param fromVoice - Current voice ID
 * @param toVoice - Target voice ID
 * @param detectedLocale - Detected locale code
 * @returns Natural transition message
 */
export async function generateTransitionMessage(
    fromVoice: string,
    toVoice: string,
    detectedLocale: string
): Promise<string> {
    try {
        const client = new BedrockRuntimeClient({
            region: process.env.AWS_REGION || 'us-east-1'
        });

        const prompt = `Generate a brief, natural transition message for a voice assistant switching voices.

Context:
- Switching from ${fromVoice} to ${toVoice}
- Detected user locale: ${detectedLocale}
- Keep it under 15 words
- Sound professional, warm, and helpful
- Do NOT mention technical details like voice IDs or locale codes

Example: "I'm switching to a voice that better matches your accent."

Generate transition message:`;

        const command = new InvokeModelCommand({
            modelId: 'us.amazon.nova-pro-v1:0',
            contentType: 'application/json',
            accept: 'application/json',
            body: JSON.stringify({
                messages: [
                    {
                        role: 'user',
                        content: [{ text: prompt }]
                    }
                ],
                inferenceConfig: {
                    maxTokens: 50,
                    temperature: 0.7,
                    topP: 0.9
                }
            })
        });

        const response = await client.send(command);
        const responseBody = JSON.parse(new TextDecoder().decode(response.body));
        const message = responseBody.output?.message?.content?.[0]?.text ||
            "I'm adjusting my voice to better match our conversation.";

        return message.trim();
    } catch (error) {
        console.error('[TransitionHandler] Failed to generate transition message:', error);
        // Fallback message
        return "I'm switching to a more natural sounding voice for you.";
    }
}

/**
 * Determine if voice should switch based on detected locale
 * 
 * @param session - Current client session
 * @param detectedLocale - Detected locale from Transcribe
 * @param confidence - Confidence score (0.0 - 1.0)
 * @returns Voice switch transition decision
 */
export function shouldSwitchVoice(
    session: Partial<ClientSession>,
    detectedLocale: string,
    confidence: number
): VoiceSwitchTransition {
    const currentVoice = session.voiceId || 'matthew';

    // Check if voice lock is enabled
    if (session.voiceLockEnabled) {
        console.log('[TransitionHandler] Voice lock enabled - no switch');
        return {
            shouldSwitch: false,
            fromVoice: currentVoice,
            toVoice: currentVoice,
            detectedLocale,
            confidence,
            transitionMessage: ''
        };
    }

    // Get recommended voice from mapping
    const voiceMapping = session.voiceMapping || {};
    const recommendedVoice = voiceMapping[detectedLocale];

    if (!recommendedVoice) {
        console.log(`[TransitionHandler] No voice mapping for locale: ${detectedLocale}`);
        return {
            shouldSwitch: false,
            fromVoice: currentVoice,
            toVoice: currentVoice,
            detectedLocale,
            confidence,
            transitionMessage: ''
        };
    }

    // Check if voice would actually change
    if (recommendedVoice === currentVoice) {
        console.log(`[TransitionHandler] Voice already matches: ${currentVoice}`);
        return {
            shouldSwitch: false,
            fromVoice: currentVoice,
            toVoice: currentVoice,
            detectedLocale,
            confidence,
            transitionMessage: ''
        };
    }

    // Confidence threshold check (0.7 = 70%)
    if (confidence < 0.7) {
        console.log(`[TransitionHandler] Confidence too low: ${confidence.toFixed(2)} < 0.70`);
        return {
            shouldSwitch: false,
            fromVoice: currentVoice,
            toVoice: currentVoice,
            detectedLocale,
            confidence,
            transitionMessage: ''
        };
    }

    // All checks passed - switch voice
    console.log(`[TransitionHandler] Voice switch approved: ${currentVoice} → ${recommendedVoice}`);
    return {
        shouldSwitch: true,
        fromVoice: currentVoice,
        toVoice: recommendedVoice,
        detectedLocale,
        confidence,
        transitionMessage: '' // Will be generated separately
    };
}

/**
 * Execute voice switch workflow with transition notification
 * 
 * @param transition - Voice switch transition decision
 * @param sendText - Function to send text to TTS
 * @param updateVoice - Function to update voice configuration
 * @returns Promise that resolves when transition is complete
 */
export async function executeVoiceSwitch(
    transition: VoiceSwitchTransition,
    sendText: (text: string) => Promise<void>,
    updateVoice: (voiceId: string) => Promise<void>
): Promise<void> {
    if (!transition.shouldSwitch) {
        return;
    }

    console.log(`[TransitionHandler] Executing voice switch: ${transition.fromVoice} → ${transition.toVoice}`);

    // Generate transition message
    const transitionMessage = await generateTransitionMessage(
        transition.fromVoice,
        transition.toVoice,
        transition.detectedLocale
    );

    console.log(`[TransitionHandler] Transition message: "${transitionMessage}"`);

    // Play transition message with OLD voice
    await sendText(transitionMessage);

    // Wait for transition message to complete (estimate based on length)
    const estimatedDuration = Math.max(2000, transitionMessage.length * 100); // ~100ms per character
    await new Promise(resolve => setTimeout(resolve, estimatedDuration));

    // Update to new voice
    await updateVoice(transition.toVoice);

    console.log(`[TransitionHandler] Voice switch complete: now using ${transition.toVoice}`);
}
